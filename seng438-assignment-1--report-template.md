>   **SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#1 – Introduction to Testing and Defect Tracking**

| Group \#:       |   |
|-----------------|---|
| Student Names:  | Agampreet Aulakh |
|                 | Melanie Nguyen |
|                 | Jeff Roszell |
|                 | Heidi Schaefer |

**Table of Contents**

(When you finish writing, update the following list using right click, then
“Update Field”)

[1 Introduction	1](#_Toc439194677)

[2 High-level description of the exploratory testing plan	1](#_Toc439194678)

[3 Comparison of exploratory and manual functional testing	1](#_Toc439194679)

[4 Notes and discussion of the peer reviews of defect reports	1](#_Toc439194680)

[5 How the pair testing was managed and team work/effort was
divided	1](#_Toc439194681)

[6 Difficulties encountered, challenges overcome, and lessons
learned	1](#_Toc439194682)

[7 Comments/feedback on the lab and lab document itself	1](#_Toc439194683)

# Introduction

The purpose of this lab was to have an introduction to the software testing
process, and the application Backlog. A Java ATM application was provided 
with two versions (1.0 and 1.1). Once we familiarized ourselves with the application
and Backlog, exploratory testing, manual scripted testing, and regression testing
were performed.

Before this lab, we were aware of how exploratory and scripted testing were performed,
but had limited prior experience conducting and documenting testing in a more procedural
manner. The exploratory is a more natural form of testing, where realistic scenarios
are performed on the application with no strict plan, and the results compiled. 
Scripted testing is more structured, as tests are designed first and executed after.

# High-level description of the exploratory testing plan

Appendix B of the lab document was read through before creating the exploratory test plan.
From these requirements, we chose the following functions to target:
-   On button
-   Off button
-   Number buttons
-   Enter, cancel, clear buttons
-   Card verification
-   PIN verification
-   Initial balance settings
-   Withdrawals
-   Deposits
-   Receipt output
-   Log output

From these functions, we divided the work into customer and operator components,
and created more specific tests:

Customer
-   Functionality of both cards
-   Withdrawals made in varying amounts from each account
-   Deposits made in varying amounts, to each account
-   Transfers made in varying amounts between all combinations of accounts
-   Balance inquiries made for each account
-   Output of receipt terminal
-   Button functionality (numbers, enter, cancel, clear)

Operator
-   Start servicing of customers
-   Stop servicing of customers
-   Verification and entry of cash in machine
-   Handling of insufficient funds
-   Log output
-   Boundary conditions of PIN entry

Due to the large number of sequences in which these functions can be performed,
we performed exploratory testing in the small for this application.

# Comparison of exploratory and manual functional testing

As a script for manual functional testing was given, the comparison between
the production of exploratory vs manual functional tests not valid for this lab.

After conducting both testing styles, the results produced were quite
similar. As the application was fairly small and something we were all
familiar with, the main functionalities made obvious cases for our 
exploratory testing, thus had been written in the scripted testing as well. 
The most noticeable way the two types differed from one another
was in the more unexpected inputs which were tested in the most human way:
pressing buttons which were not intended to be pressed. These tests were not
planned in the manual functional test script, and were a result of realistic
human trial and error. Another distinction between the two was the initial 
system state column of the manual functional testing script. At times it was 
difficult to remember the initial state of the system when exploratory testing 
was performed, as previously mentioned due to the vast number of possible sequences.


-   Note that you need to submit a report generated by your defect tracking
    system, containing all defects recorded in the system.

# Notes and discussion of the peer reviews of defect reports

Text…

# How the pair testing was managed and team work/effort was divided 

Exploratory testing was divided in two sections: customer and operator.
Customer testing was performed by Melanie Nguyen and Heidi Schaefer.
Operator testing was performed by Agam Aulakh and Jeff Roszell.
Scripted testing was performed by Jeff Roszell and Heidi Schaefer.
Defect reports were written by all group members.

# Difficulties encountered, challenges overcome, and lessons learned

At first, exploratory testing was a bit overwhelming. As there were so many bugs 
in the initial system, it was easy to second guess if we had clicked the button 
we intended to (for example, when $20 was requested to be withdrawn, $40 was dispensed; 
a transfer from checking to savings showed up as being from savings to checking 
on receipt). In order to overcome this, we needed to be careful when recording
each step along the way. It was also easy to see patterns in some bugs (for example,
$20 more was being dispensed for withdrawals under $100), but these patterns did not
exist in all variables (when $200 was requested, $20 was dispensed). This showed
the importance of not making assumptions or generalizations when testing applications
for which you cannot see the code, and being thorough in testing many variables.
A good lesson to learn was to press buttons which were not intended to be used,
such as pressing buttons with no available option, or seeing the ATM log as a customer.
It is important to ensure the system cannot be exploited when used improperly.

# Comments/feedback on the lab and lab document itself

Text…
